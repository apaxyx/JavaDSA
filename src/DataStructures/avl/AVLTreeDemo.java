package DataStructures.avl;
/*
平衡二叉树
平衡二叉搜索树
Self-balancing binary search tree
AVL树

可以保证查询效率较高
具有以下特点：这是一棵空树或它的左右两个子
树的高度差的绝对不值不超过1，并且左右两棵子
树都是一棵平衡二叉树
平衡二叉树的常用实现方法有：红黑树、替罪羊树、Trap、伸展树等

--------------------------------------------------------

多叉树
在二叉树中，每个节点有数据项，最多有两个子节点，如果允许每个节点可以有更多
的数据项和更多的子节点，主是多叉树，multiway tree
2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树
进行优化

B树(Balance Tree)通过重新组织节点，降低树的高度，并且减少I/O读写次数来提升效率
文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小
设为等于一个页（页的大小通常为4K）这样每个节点只需要一次I/O就可以
完全载入
将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读
到想要的元素，B树(B+树)广泛应用于文件存储系统以及数据库系统中

2-3树
2-3树是最简单的B树结构，具有如下特点
1)2-3树的所有叶子节点都在同一层（只要是B树都满足这个条件）
2)有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点
3)有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4)2-3树是由二节点和三节点构成的树

B树的说明
1.B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4
2.B树的搜索，从根结点开始，对结点内的关键字（有序）进行二分查找，如果
命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿
子指针为空，或已经是叶子结点
3.关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据
4.搜索有可能在非叶子结点结束
5.其搜索性能造价于在关键字全集内做一次二分查找

B+树的说明
1)B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中
（B树可以在非叶子结点命中），其性能也造价于在关键字全集做一次
二分查找
2)所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点
（也叫稠密索引）），且链表中的关键字（数据）恰好是有序的
3)不可能在非叶子结点命中
4)非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是
存储（关键字）数据的数据层
5)更适合文件索引系统
6)B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然

B*树的说明
B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针
1)B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用
率为2/3,而B+树的块的最低使用率为B+树的1/2
2)从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空
间使用率更高

AA树、伸展树、treap树、k-d树
 */
public class AVLTreeDemo {

    public static void main(String[] args) {
        //int[] arr = {4,3,6,5,7,8};
        //int[] arr = { 10, 12, 8, 9, 7, 6 };
        int[] arr = { 10, 11, 7, 6, 8, 9 };
        //创建一个 AVLTree对象
        AVLTree avlTree = new AVLTree();
        //添加结点
        for(int i=0; i < arr.length; i++) {
            avlTree.add(new Node(arr[i]));
        }

        //遍历
        System.out.println("中序遍历");
        avlTree.infixOrder();

        System.out.println("在平衡处理~~");
        System.out.println("树的高度=" + avlTree.getRoot().height()); //3
        System.out.println("树的左子树高度=" + avlTree.getRoot().leftHeight()); // 2
        System.out.println("树的右子树高度=" + avlTree.getRoot().rightHeight()); // 2
        System.out.println("当前的根结点=" + avlTree.getRoot());//8
    }
}
